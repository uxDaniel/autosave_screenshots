from os import walk, path, rename, remove, environ
from time import sleep
import imghdr, struct, datetime
import logging


class ScreenshotsMover:
    def __init__(
        self,
        sourcepath=environ['USERPROFILE']+r"\AppData\Local\Packages\MicrosoftWindows.Client.CBS_cw5n1h2txyewy\TempState\ScreenClip",
        targetpath=environ['USERPROFILE']+r"\Pictures\Screenshots",
        preview_dimensions=[(728, 360), (637,315), (455, 225), (364, 180)], # previews generated by Snipping Tool, to be ignored
        delay_seconds=2,
        do_cleanup=True,
    ):
        self.sourcepath = sourcepath
        self.targetpath = targetpath
        self.preview_dimensions = preview_dimensions
        self.delay_seconds = delay_seconds
        self.do_cleanup = do_cleanup

        imghdr.tests.append(ScreenshotsMover.test_jpeg)
        logging.basicConfig(
            filename='winsnip.log',
            format='%(asctime)s %(message)s',
            encoding='utf-8',
            level=logging.DEBUG
        )


    # From https://stackoverflow.com/a/39778771/259824
    @staticmethod
    def test_jpeg(h, f):
        # SOI APP2 + ICC_PROFILE
        if h[0:4] == '\xff\xd8\xff\xe2' and h[6:17] == b'ICC_PROFILE':
            print("A")
            return 'jpeg'
        # SOI APP14 + Adobe
        if h[0:4] == '\xff\xd8\xff\xee' and h[6:11] == b'Adobe':
            return 'jpeg'
        # SOI DQT
        if h[0:4] == '\xff\xd8\xff\xdb':
            return 'jpeg'

    @staticmethod
    def get_image_size(fname):
        '''Determine the image type of fhandle and return its size.'''
        with open(fname, 'rb') as fhandle:
            head = fhandle.read(24)
            if len(head) != 24:
                return
            what = imghdr.what(None, head)
            if what == 'png':
                check = struct.unpack('>i', head[4:8])[0]
                if check != 0x0d0a1a0a:
                    return
                width, height = struct.unpack('>ii', head[16:24])
            elif what == 'gif':
                width, height = struct.unpack('<HH', head[6:10])
            elif what == 'jpeg':
                try:
                    fhandle.seek(0) # Read 0xff next
                    size = 2
                    ftype = 0
                    while not 0xc0 <= ftype <= 0xcf or ftype in (0xc4, 0xc8, 0xcc):
                        fhandle.seek(size, 1)
                        byte = fhandle.read(1)
                        while ord(byte) == 0xff:
                            byte = fhandle.read(1)
                        ftype = ord(byte)
                        size = struct.unpack('>H', fhandle.read(2))[0] - 2
                    # We are at a SOFn block
                    fhandle.seek(1, 1)  # Skip `precision' byte.
                    height, width = struct.unpack('>HH', fhandle.read(4))
                except Exception: #IGNORE:W0703
                    return
            else:
                return
            return width, height

    def get_screenshot_filenames(self):
        # get the filenames
        dirpath, dirnames, filenames = next(walk(self.sourcepath), (None, None, []))

        # leave only full-sized screenshots
        screenshots = []
        for name in filenames:
            file_path = f"{self.sourcepath}\\{name}"
            if name.endswith('.png'): # only png images
                dimensions = ScreenshotsMover.get_image_size(file_path)
                if dimensions not in self.preview_dimensions: # only full-sized images
                    screenshots.append(name)
                elif self.do_cleanup:
                    try:
                        remove(file_path)
                        logging.info(f"Removed {name}")
                    except:
                        pass
            elif self.do_cleanup:
                try:
                    remove(file_path)
                    logging.info(f"Removed {name}")
                except:
                    pass
        return screenshots

    def get_new_filenames(self, old_filenames):
        new_filenames = []
        for name in old_filenames:
            image_path = f"{self.sourcepath}\\{name}"

            # get the file creation date in iso-ish format
            seconds_since_epoch = path.getctime(image_path)
            dtime = datetime.datetime.fromtimestamp(seconds_since_epoch)
            iso_format = dtime.isoformat(sep=' ', timespec='seconds')
            creation_date = iso_format.replace(':', '-')

            filename = f"{creation_date}.png"
            new_filenames.append(filename)
        return new_filenames
    
    def move_screenshots(self, old_filenames, new_filenames):
        for i in range(len(old_filenames)):
            old_path = f"{self.sourcepath}\\{old_filenames[i]}"
            new_path = f"{self.targetpath}\\{new_filenames[i]}"
            rename(old_path, new_path)

            source=self.sourcepath[self.sourcepath.rfind("\\")+1:]
            target=self.targetpath[self.targetpath.rfind("\\")+1:]
            logging.info(f"{source}\\{old_filenames[i]}  âž”   {target}\\{new_filenames[i]}")

    def main(self):
        logging.info(f"Monitoring {self.sourcepath}")
        while True:
            old_filenames = self.get_screenshot_filenames()
            if old_filenames:
                new_filenames = self.get_new_filenames(old_filenames)
                self.move_screenshots(old_filenames, new_filenames)
            sleep(self.delay_seconds) # sleep 2 seconds


if __name__ == "__main__":
    sm = ScreenshotsMover()
    sm.main()